# Задание 4

1. Первым делом создадим файлы с нужными названиями и скопируем туда код. После этого добавим в начало каждого файла(после #include) <stdio.h> - библиотеку стандартного ввода и вывода, данная строка позволяет обозначить компилятору во время препроцессинга, что для данных операций будет использоваться именно она.
2. Далее выполним "gcc -c file1.c file2.c main.c", данная команда выполняет операцию компилировнаия файлов в объектные файлы, то есть все те же операции, что и для создания исполняемых файлов(препроцессинг, компиляция, ассемблирования), но без линкинга, то есть на данном этапе в объектном файле, например, не существует связи между объявлеными глобальными перемнными и их реализацией в другом файле. Для успешной компиляции стоит убрать static из file1.c, по той причине, что static делает из переменной статическую, которая в свою очередь сущесвует только в file1.c и не может быть подвержена операции extern
3. Тепер с помощью команды nm иследуем таблицу символов объектных файлов. 
   1. Для файла file1.o
    0000000000000058 D _global_var
    0000000000000000 T _print_from_file1
                     U _printf
    000000000000005c D _static_var
    0000000000000060 s l_.str
    000000000000007c s l_.str.1
    0000000000000000 t ltmp0
    0000000000000058 d ltmp1
    0000000000000060 s ltmp2
    0000000000000098 s ltmp3
    
    Первый столбец столбец содержит число - адрес символа в память. Далее идет тип символа:
    T: Символ определён в текстовом сегменте (обычно это функции).
    D: Символ определён в сегменте данных (глобальные переменные).
    B: Символ определён в сегменте BSS (неинициализированные глобальные переменные).
    U: Символ неопределённый, то есть он ссылается на функцию или переменную, которая определена в другом объектном файле или библиотеке. 
    S: Эта секция предназначена для небольших объектов, общих символов, а также данных, определенных пользователем
    s: локальный символ в секции small data
    t: локальный символо в текстовым сегменте
    d: локальный символ в секции данных

    Потом идет имя символа, которое может быть именем функции или переменной.

    В file1.o _printf - не имеет адреса и имеет тип U, все от того, что файл скомпилирован до линковки, следовательно реалицаия функции еще не была связана с ее вызовом. static_var видная в файле так как там же она и определяется(ей присваивается значение и тип), тоже самое можно сказать и про global_var. Мы напрямую примваемае значние этой переменной в file1, а в file2 мы пытаемся изменить значение глобпльной переменной, напрямую присвоев ей значение, тк файл еще не слинкован мы просто создаем новую переменную. 

    0000000000000060 s l_.str - Этот символ представляет собой локальную строку или данные, которые хранятся в сегменте "small data". Такие символы обычно используются для хранения небольших данных, таких как строки или константы, которые могут быть использованы только внутри данного файла. Использование локальных символов позволяет избежать конфликтов имён в больших проектах.

    0000000000000000 t ltmp0 - Это временная метка или переменная, используемая только внутри функции или блока кода. Символы типа t обычно используются для обозначения временных данных, которые не должны быть доступны за пределами текущего контекста.

    0000000000000058 d ltmp1 - Этот символ представляет собой локальную переменную, которая хранится в сегменте данных. Такие переменные могут содержать инициализированные значения и доступны только внутри файла, где они определены.
    

   2. Для file2.o
    000000000000005c D _global_var
    0000000000000000 T _print_from_file2
                     U _printf
                     U _static_var
    0000000000000060 s l_.str
    000000000000007c s l_.str.1
    0000000000000000 t ltmp0
    000000000000005c d ltmp1
    0000000000000060 s ltmp2
    0000000000000098 s ltmp3

   3. Для main.o

                     U _global_var
    0000000000000000 T _main
                     U _print_from_file1
                     U _print_from_file2
                     U _printf
    0000000000000054 s l_.str
    0000000000000000 t ltmp0
    0000000000000054 s ltmp1
    0000000000000070 s ltmp2

    Вообщем многие функции неопределены(имеют тип U) тк еще не было линковки.

4. Вводим команду gcc file1.o file2.o main.o -o program и получаем ошибку линковки.
5. После исправления, изменился только nm file2.o, global_var преобрела тип U, тк теперь она неопределена и ждет пока линковщик возьмет значения из file1. static_var - просто была удалена из file2.o
6. Посмотрим, где хранятся переменные в памяти:
    1. Для file1.o
        file1.o:        file format mach-o arm64

        SYMBOL TABLE:
        0000000000000000 l     F __TEXT,__text ltmp0
        0000000000000060 l     O __TEXT,__cstring l_.str
        000000000000005c l     O __DATA,__data _static_var
        000000000000007c l     O __TEXT,__cstring l_.str.1
        0000000000000058 l     O __DATA,__data ltmp1
        0000000000000060 l     O __TEXT,__cstring ltmp2
        0000000000000098 l     O __LD,__compact_unwind ltmp3
        0000000000000058 g     O __DATA,__data _global_var
        0000000000000000 g     F __TEXT,__text _print_from_file1
        0000000000000000         *UND* _printf

    2. Для file2.o
        file2.o:        file format mach-o arm64

        SYMBOL TABLE:
        0000000000000000 l     F __TEXT,__text ltmp0
        000000000000003c l     O __TEXT,__cstring l_.str
        000000000000003c l     O __TEXT,__cstring ltmp1
        0000000000000058 l     O __LD,__compact_unwind ltmp2
        0000000000000000 g     F __TEXT,__text _print_from_file2
        0000000000000000         *UND* _global_var
        0000000000000000         *UND* _printf
   
   3. Для main.o
        main.o: file format mach-o arm64

        SYMBOL TABLE:
        0000000000000000 l     F __TEXT,__text ltmp0
        0000000000000054 l     O __TEXT,__cstring l_.str
        0000000000000054 l     O __TEXT,__cstring ltmp1
        0000000000000070 l     O __LD,__compact_unwind ltmp2
        0000000000000000 g     F __TEXT,__text _main
        0000000000000000         *UND* _global_var
        0000000000000000         *UND* _print_from_file1
        0000000000000000         *UND* _print_from_file2
        0000000000000000         *UND* _printf
    
    Глобальные переменные храняться .data, неиницилизированные глобальные переменные в .bss, в .text хранятся, как правило, функции. 

7. Проверим строки.
   1. Вывод strings program
    file1.c -> global_var = %d
    file1.c -> static_var = %d
    file2.c -> global_var = %d
    main.c -> global_var = %d 

    Именно это и содержалось в printf() в file1 и file2
8. Далее нужно выполнить objdump -x program, но к сожалению из-за несовместимости архитектур данная команда выдает "program: file format mach-o arm64" и "error: 'program': Invalid/Unsupported object file format". Таким образом различие в динамической и статической компиляциях я не заметил. Я попробовал утилиту "otool", но она не внесла ясности в присходящее.
   
9. Почему global_var есть в .data, а static_var нет в таблице символов?
    Обе эти переменные находяться в .data. Доказано эмперически. 
   


# Задание 1,2

1. global_var будет находиться в секции .data
2. uninitialized_global_var будет находиться в секции .css
3. static_var будет находиться в секции .data
4. global_point будет находиться в секции .data
5. local_var будет находиться в стеке
6. static_local_var будет находиться в стеке
7. auto_var будет находиться в стеке
8. dynamic_var будет находиться в кучевой памяти
9. stack_point будет находиться в стеке

0000000100000000 T __mh_execute_header
                 U _free
0000000100008004 D _global_point
0000000100008000 D _global_var
0000000100003ef0 T _main
                 U _malloc
0000000100003ec4 T _print_message
000000010000800c d _print_message.static_local_var
                 U _printf
0000000100008010 S _uninitialized_global_var - Эта секция предназначена для небольших объектов, общих символов, а также данных, определенных пользователем

# Задание 3

До связывния fuel.o

0000000000000000 T _check_fuel
0000000000000000 t ltmp0
0000000000000030 s ltmp1

Функция check_fuel имеет формат T, как и все функции

До связывния navigation.o
0000000000000000 T _calculate_distance
0000000000000000 t ltmp0
0000000000000020 s ltmp1

Тоже самое и функцией calculate_distance

До связывания main.o
                 U _calculate_distance
                 U _check_fuel
0000000000000000 T _main
                 U _printf
                 U _scanf
0000000000000120 s l_.str
000000000000013c s l_.str.1
000000000000013f s l_.str.2
000000000000014f s l_.str.3
000000000000015b s l_.str.4
000000000000017c s l_.str.5
000000000000017f s l_.str.6
00000000000001a6 s l_.str.7
00000000000001b5 s l_.str.8
0000000000000000 t ltmp0
0000000000000120 s ltmp1
00000000000001c8 s ltmp2


В main.o определена только main, остальные имееют тип U, так как еще не было процесса линкинга

Исполняемый файл project

0000000100000000 T __mh_execute_header
0000000100003ec0 T _calculate_distance
0000000100003d74 T _check_fuel
0000000100003da0 T _main
                 U _printf
                 U _scanf

Все функции определены и имеют тип T, кроме printf и scanf по неизвестной мне причине



